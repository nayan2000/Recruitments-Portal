Implementation of Queues in Multi-Threading:

Before you begin reading this article, I would like to strongly recommend some background reading to ensure that you are well equiped with the basic knowledge of threads as well as the basic knowledge
of queues before we try to mix the two together.

1. What are queues? (may skip if you already know)
    https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
    https://www.geeksforgeeks.org/queue-data-structure/

2. How are queues implimented in python?    
    https://docs.python.org/2/library/queue.html
    Note: the only two methods you really need to know are Queue.put() (which basically just enqueues) and Queue.get() (which basically just dequeues)

3. Basics of Threading as explained through it's implementation in python:
    https://www.geeksforgeeks.org/multithreading-python-set-1/
    https://www.geeksforgeeks.org/multithreading-in-python-set-2-synchronization/
    https://docs.python.org/3/library/threading.html
    Note: I suggest additional research if you're not fully sure of what threads are at this point, it may take a while for it to sink in (because it may be a new concept to you)

And now you'll find this article a lot easier to understand. Let's begin.




I want to begin with a loose analogy and then I'll show you how it's related to the topic at hand.

Consider a small team of people working together: a manager who assigns work and some employees who will do the assigned work. Now each of the employees will report to the manager for work and then 
they will begin doing that assigned work independently of each other and simultaneously. In the end the work gets done pretty quickly since everyone is working simultaneously. The end.
That's it for the analogy, short and simple.




Now let's begin looking at the outline for how to implement queues in threading, just to give a good bird's eye view of what we're going to do:

step 1:
We will use queues to store the work that is required to be done. The advantage of using a queue is to provide a sense of order as to how the tasks are to be done. Python's built-in Queue data 
structure even provides some extra support for threading. All the better for us. Creating this queue is the first step.

step 2:
We will generate several threads (which are the employees in the above analogy) and then set their target function to a "worker" or "threader" function (the manager in the above analogy). Each of these threads will need to be a daemon thread. The reason for this, I'll explain a little later on in this article. 

step 3:
Now we're going to need to create this the "worker"/"threader" function. This function will basically keep assiging work to the tread as from the queue and have it complete a work function (the actual task). This "worker"/"threader" function like a dispenser, a work dispenser.

step 4:
We finally create the work function for the thread to actually do.


Great! so now we have an idea of the flow of things. Let's look at an actual example in python. To begin, we'll start with a simple example.

[example]

[result]

Now after reading the code and all of the included comments, let's review what's happening.

First, we define the work to be done by creating a queue of induvisual tasks to be completed. Each one of these tasks is actually the arugment we will pass to the work function: doWork(). Then we spawn/generate 8 threads which will work simultaneously to complete the tasks stored in the queue (Note: we have defined the threads to be daemons, and the reason will be explained just after this review). To actually hook up the work to the threads, we have the worker/threader function: worker(). This function will tell each thread that calls it to keep taking the next task from the queue, complete it then mark it as completed (remember that each "task" from the queue will be the argument(s) which will be used to execute the work function doWork()). We will our have 8 threads continuously working in parallel to complete all of the work in queue. que.join() will prevent the process/program from exiting before all of the work has been completed.

Disclaimer: running too many threads at once could damage your machine. 8 is a pretty safe number though here.

Now why are our threads daemons? The simple reason is so that the threads would be killed as soon as the process/program exits. In the python threading module, all daemon threads are automatically killed (abruptly, not gracefully) when the program ends. If the threads weren't set to daemon, we'd have to go through the trouble of keeping a record of the threads, and then manually killing them.

There is one more thing I'd like to point out about the program exiting. As you may have noticed in the example from first recommended reading for threads, a Thread.join() command is used to wait for the threads to completely finish executing before letting the process exit, it "blocks" the process from exiting. However, here we do something different, we use Queue.join() to wait for all of the enqueued tasks to be completed. We don't look at the thread but rather the work to be done instead before exiting. If that work is completed, then the process will be allowed to exit and all of the daemon threads are automatically killed (which is what we want since all of the work is done anyways).


Now that we have seen first-hand how queues can be used in threading. But the example was pretty basic and doesn't really demonstrate too much of a realistic need. Let's try to look at a slightly more advanced example that will give us a slightly better idea of how they can be more useful.

[example]

let's start with understanding what this code wants to do in the first place. This program aims to create 3 files called file1.txt, file2.txt and file3.txt and populate all of them with the numbers from 0 to 99 (i.e. [0, 99]).

What's new in this code vs the previous one? 
    1. we used a thread lock in the Work function (thread locks explained in the recommended reading at the beginning of this article - Source 2 for threads)
    2. The action is different

But that's it. So it's not really all that different, but it starts to show relatively more promise for being useful. 

